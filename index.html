<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Grand Luxury Tree v17.6.5 - UI Hints</title><style>/* ================= 1. åŸºç¡€è®¾ç½® ================= */body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Microsoft YaHei', 'Songti SC', serif; }
    #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
    
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Great+Vibes&family=Monoton&family=Abril+Fatface&family=Ma+Shan+Zheng&display=swap');

    /* ================= 2. UI è§†è§‰ (V17.6.3 åŸç‰ˆæ ·å¼) ================= */:root {
        --glass-bg: rgba(20, 20, 25, 0.75);
        --glass-border: rgba(255, 255, 255, 0.08);
        --glass-highlight: rgba(255, 255, 255, 0.15);
        --accent-gold: #d4af37;
        --accent-gold-gradient: linear-gradient(135deg, #fceea7 0%, #d4af37 100%);
        --text-main: #ffffff;
        --text-sub: #b0b0b5;
        --panel-width: 210px;
        --ui-scale: 0.9; 
    }

    @media screen and (max-height: 800px) { :root { --ui-scale: 0.8; } }
    @media screen and (min-width: 2000px) { :root { --ui-scale: 1.1; } }
    :fullscreen { --ui-scale: 1.0; }

    .glass-panel {
        background: var(--glass-bg);
        backdrop-filter: blur(40px) saturate(180%);
        -webkit-backdrop-filter: blur(40px) saturate(180%);
        border-radius: 16px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6), inset 0.5px 0.5px 0px var(--glass-highlight), inset -0.5px -0.5px 0px rgba(0,0,0,0.5);
        border: 1px solid var(--glass-border);
        overflow: hidden;
        box-sizing: border-box;
    }

    #left-sidebar, .bottom-left-panel { transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
    .panel-hidden { transform: translateX(calc(-1 * var(--panel-width) - 50px)) scale(var(--ui-scale)) !important; opacity: 0 !important; pointer-events: none !important; }
    .hidden { display: none !important; }

    #left-sidebar { position: absolute; top: 15px; left: 15px; width: var(--panel-width); height: calc(100vh - 30px); display: flex; flex-direction: column; gap: 8px; z-index: 20; pointer-events: none; transform: scale(var(--ui-scale)); transform-origin: top left; }
    .scroll-content { flex: 1; overflow-y: auto; pointer-events: auto; padding: 10px; display: flex; flex-direction: column; gap: 10px; scrollbar-width: none; }
    .scroll-content::-webkit-scrollbar { display: none; }

    .bottom-left-panel { position: absolute; bottom: 15px; left: 15px; pointer-events: auto; display: grid; grid-template-columns: 1fr 1fr; gap: 5px; width: var(--panel-width); padding: 10px; box-sizing: border-box; transform: scale(var(--ui-scale)); transform-origin: bottom left; }
    .bottom-left-panel .ui-title-main { grid-column: span 2; font-size: 11px; margin-bottom: 4px; padding-bottom: 2px; }
    .bottom-left-panel .elegant-btn { width: 100%; font-size: 10px; height: 28px; }

    /* ä¿®å¤ input file æ ·å¼ */.bottom-left-panel .elegant-btn { width: 100%; font-size: 10px; height: 28px; position: relative; }
    .elegant-btn input[type="file"] { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }

    .ui-title-main { font-family: 'SimSun', 'Songti SC', serif; font-size: 14px; font-weight: bold; color: #fff1c1; text-shadow: 0 0 10px rgba(212, 175, 55, 0.3); border-bottom: 1px solid rgba(212, 175, 55, 0.2); padding-bottom: 4px; margin-bottom: 6px; letter-spacing: 2px; text-align: center; }
    .ui-title-sub { font-size: 12px; color: #b0b0b5; margin-top: 6px; margin-bottom: 3px; letter-spacing: 1px; font-weight: 700; text-transform: uppercase; }
    .control-label { color: #aaa; font-size: 11px; font-weight: 700; }
    .control-group { display: flex; flex-direction: column; gap: 2px; margin-bottom: 5px; }
    .control-row { display: flex; flex-direction: column; gap: 1px; margin-bottom: 4px; }

    .particle-scroll-container { max-height: 140px; overflow-y: auto; padding-right: 4px; margin-right: -4px; border-left: 2px solid rgba(212,175,55,0.1); padding-left: 6px; }
    .particle-scroll-container::-webkit-scrollbar { width: 3px; }
    .particle-scroll-container::-webkit-scrollbar-track { background: rgba(255,255,255,0.02); border-radius: 2px; }
    .particle-scroll-container::-webkit-scrollbar-thumb { background: rgba(212,175,55,0.4); border-radius: 2px; }

    .elegant-btn { 
        background: rgba(255, 255, 255, 0.03); 
        border: 1px solid rgba(212, 175, 55, 0.3); 
        color: #d4af37; 
        padding: 5px 0; 
        cursor: pointer; 
        text-transform: uppercase; 
        font-size: 10px; 
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        border-radius: 4px; 
        box-sizing: border-box; 
        position: relative; 
        overflow: hidden; 
        font-family: 'Microsoft YaHei', sans-serif; 
        text-decoration: none;
    }
    .elegant-btn:hover { 
        background: rgba(212, 175, 55, 0.15); 
        border-color: #fff1c1; 
        color: #fff; 
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.6),
                    0 0 40px rgba(212, 175, 55, 0.3),
                    inset 0 0 20px rgba(212, 175, 55, 0.1); 
        text-shadow: 0 0 8px rgba(255, 255, 255, 1);
        transform: translateY(-1px);
    }
    .elegant-btn:active { 
        transform: scale(0.95) translateY(0);
        box-shadow: 0 0 10px rgba(212, 175, 55, 0.4);
    }
    .btn-red { border-color: #844; color: #eaa; }
    .btn-red:hover { background: #522; box-shadow: 0 0 15px rgba(255, 50, 50, 0.3); }

    input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 3px 0; }
    input[type=range]:focus { outline: none; }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 1px; cursor: pointer; background: rgba(255, 255, 255, 0.2); border-radius: 1px; }
    input[type=range]::-webkit-slider-thumb { height: 9px; width: 9px; border-radius: 50%; background: #d4af37; cursor: pointer; -webkit-appearance: none; margin-top: -4px; box-shadow: 0 0 5px rgba(212, 175, 55, 0.8); border: 1px solid #000; transition: transform 0.1s; }
    input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.3); background: #fff; }

    .input-glass { background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.1); color: #eebb66; padding: 3px; font-size: 10px; outline: none; transition: 0.3s; border-radius: 2px; width: 100%; box-sizing: border-box; text-align: center; height: 24px; }
    .input-glass:focus { border-color: #d4af37; background: rgba(0,0,0,0.6); }
    select.input-glass { cursor: pointer; }
    select.input-glass option { background: #000; color: #d4af37; }
    input[type="color"] { -webkit-appearance: none; border: none; width: 100%; height: 16px; cursor: pointer; padding: 0; background: none; }

    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
    #title-container { position: absolute; top: 10%; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: auto; cursor: move; z-index: 50; transition: color 0.2s; user-select: none; padding: 10px; }
    .top-left-panel { pointer-events: auto; display: flex; flex-direction: column; gap: 4px; padding: 10px; width: 100%; box-sizing: border-box; }
    .interaction-grid { display: flex; gap: 4px; margin-bottom: 4px; }
    .direction-pad { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 3px; margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.05); }
    .dir-btn { background: rgba(255,255,255,0.03); border: 1px solid rgba(212,175,55,0.2); color: #d4af37; text-align: center; cursor: pointer; padding: 5px 0; border-radius: 2px; font-size: 11px; user-select: none; transition: 0.2s; }
    .dir-btn:hover { background: rgba(212,175,55,0.2); color: #fff; box-shadow: 0 0 8px rgba(212,175,55,0.2); }
    .dir-btn:active { background: #d4af37; color: #000; }
    
    #top-right-controls { position: absolute; top: 15px; right: 15px; pointer-events: auto; display: flex; flex-direction: column; gap: 8px; align-items: flex-end; z-index: 50; }
    #webcam-wrapper { position: absolute; bottom: 15px; right: 15px; width: 160px; height: 120px; border: 1px solid rgba(212, 175, 55, 0.5); border-radius: 4px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.9); overflow: hidden; z-index: 20; pointer-events: auto; background: #000; transition: opacity 0.4s ease, transform 0.4s ease; }
    #webcam-wrapper.camera-hidden { opacity: 0; pointer-events: none; transform: translateY(10px); }
    #webcam-canvas { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); display: block; }
    #cam-status { position: absolute; bottom: 5px; right: 5px; width: 6px; height: 6px; background: #550000; border-radius: 50%; box-shadow: 0 0 4px #ff0000; z-index: 30; transition: 0.2s; }
    #cam-status.active { background: #00ff00; box-shadow: 0 0 6px #00ff00; }
    
    #delete-manager { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 60; display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; backdrop-filter: blur(10px); }
    #photo-grid { display: flex; flex-wrap: wrap; gap: 15px; width: 70%; height: 60%; overflow-y: auto; justify-content: center; padding: 20px; border: 1px solid rgba(212,175,55,0.3); margin: 20px 0; background: rgba(0,0,0,0.5); border-radius: 8px; }
    .photo-item { width: 80px; height: 80px; position: relative; border: 1px solid #d4af37; transition: 0.2s; cursor: pointer; }
    .photo-item:hover { transform: scale(1.1); border-color: #fff; box-shadow: 0 0 15px rgba(212,175,55,0.5); }
    .photo-thumb { width: 100%; height: 100%; object-fit: cover; }
    .delete-x { position: absolute; top: -8px; right: -8px; width: 20px; height: 20px; background: #900; color: white; border-radius: 50%; text-align: center; line-height: 18px; font-size: 12px; cursor: pointer; font-weight: bold; border: 1px solid #fff; }
    .manager-title { color: #d4af37; font-size: 20px; font-family: 'Microsoft YaHei', serif; letter-spacing: 2px; }
    
    #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #050505; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s ease-out; }
    .spinner { width: 50px; height: 50px; border: 1px solid rgba(212, 175, 55, 0.1); border-top: 2px solid #d4af37; border-radius: 50%; animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .loader-text { color: #d4af37; font-size: 12px; letter-spacing: 4px; margin-top: 25px; font-family: 'Cinzel', serif; opacity: 0.8; }
    
    #gesture-hint { position: absolute; bottom: 10px; width: 100%; text-align: center; color: rgba(212,175,55,0.7); font-size: 10px; pointer-events: none; text-shadow: 0 0 5px #000; z-index: 5; }
    
    /* å¾®ä¿¡æµè§ˆå™¨å…¼å®¹æ€§æç¤º */
    .wechat-tip { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: #d4af37; padding: 20px; border-radius: 8px; z-index: 1000; text-align: center; max-width: 80%; display: none; }
    .wechat-tip.show { display: block; }
    
    /* ================= æ–°å¢ç‰¹æ•ˆï¼šæ ‡é¢˜åŠ¨ç”» ================= */
    @keyframes titleGlow {
        0%, 100% { 
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.2), 
                         0 0 60px rgba(252, 238, 167, 0.3),
                         0 0 90px rgba(212, 175, 55, 0.2);
            transform: scale(1);
        }
        50% { 
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.4), 
                         0 0 80px rgba(252, 238, 167, 0.5),
                         0 0 120px rgba(212, 175, 55, 0.4);
            transform: scale(1.02);
        }
    }
    
    @keyframes titleFloat {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-5px); }
    }
    
    @keyframes titleShimmer {
        0% { background-position: -200% center; }
        100% { background-position: 200% center; }
    }
    
    .title-line {
        margin: 0; 
        transition: all 0.2s ease; 
        white-space: nowrap; 
        color: #fceea7;
        /* å¢å¼ºçš„åŠ¨ç”»æ•ˆæœ */
        animation: titleGlow 3s ease-in-out infinite, 
                   titleFloat 4s ease-in-out infinite;
        /* æ¸å˜æ–‡å­—æ•ˆæœ */
        background: linear-gradient(90deg, 
            #fceea7 0%, 
            #fff 25%, 
            #fceea7 50%, 
            #fff 75%, 
            #fceea7 100%);
        background-size: 200% auto;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        /* ä¿ç•™åŸæœ‰çš„æ–‡å­—é˜´å½±ä½œä¸ºåå¤‡ */
        text-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
    }
    
    /* å¦‚æœæµè§ˆå™¨ä¸æ”¯æŒèƒŒæ™¯è£å‰ªï¼Œä½¿ç”¨æ–‡å­—é˜´å½± */
    @supports not (-webkit-background-clip: text) {
        .title-line {
            -webkit-text-fill-color: #fceea7;
            background: none;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.2),
                         0 0 60px rgba(252, 238, 167, 0.3),
                         0 0 90px rgba(212, 175, 55, 0.2);
        }
    }
    
    /* ================= æ–°å¢ç‰¹æ•ˆï¼šæŒ‰é’®å…‰æ™•æ•ˆæœ ================= */
    .elegant-btn::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(212, 175, 55, 0.4) 0%, transparent 70%);
        transform: translate(-50%, -50%);
        transition: width 0.6s ease, height 0.6s ease, opacity 0.6s ease;
        opacity: 0;
        pointer-events: none;
        z-index: -1;
    }
    
    .elegant-btn:hover::before {
        width: 200px;
        height: 200px;
        opacity: 1;
    }
    
    .elegant-btn::after {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255, 255, 255, 0.2), 
            transparent);
        transition: left 0.5s ease;
    }
    
    .elegant-btn:hover::after {
        left: 100%;
    }
    
    /* ================= æ–°å¢ç‰¹æ•ˆï¼šUIé¢æ¿è¿›å…¥åŠ¨ç”» ================= */
    @keyframes slideInLeft {
        from {
            opacity: 0;
            transform: translateX(-50px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
    }
    
    @keyframes slideInBottom {
        from {
            opacity: 0;
            transform: translateY(50px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }
    
    @keyframes fadeInScale {
        from {
            opacity: 0;
            transform: scale(0.9);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    #left-sidebar {
        animation: slideInLeft 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    .bottom-left-panel {
        animation: slideInBottom 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        animation-delay: 0.2s;
        opacity: 0;
    }
    
    #top-right-controls {
        animation: fadeInScale 0.5s ease-out forwards;
        animation-delay: 0.1s;
        opacity: 0;
    }
    
    #title-container {
        animation: fadeInScale 0.8s ease-out forwards;
        animation-delay: 0.3s;
        opacity: 0;
    }
    
    /* ================= æ–°å¢ç‰¹æ•ˆï¼šç…§ç‰‡åŠ è½½åŠ¨ç”» ================= */
    @keyframes photoFadeIn {
        from {
            opacity: 0;
            transform: scale(0.8) rotateY(90deg);
        }
        to {
            opacity: 1;
            transform: scale(1) rotateY(0deg);
        }
    }
    
    .photo-item {
        animation: photoFadeIn 0.5s ease-out forwards;
    }
    
    /* ================= æ–°å¢ç‰¹æ•ˆï¼šæ¨¡å¼åˆ‡æ¢æç¤º ================= */
    @keyframes modeSwitchPulse {
        0%, 100% {
            transform: scale(1);
            opacity: 0.7;
        }
        50% {
            transform: scale(1.1);
            opacity: 1;
        }
    }
    
    .mode-switch-indicator {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #d4af37;
        font-size: 24px;
        font-weight: bold;
        text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
        pointer-events: none;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.3s;
    }
    
    .mode-switch-indicator.show {
        opacity: 1;
        animation: modeSwitchPulse 0.6s ease-out;
    }
    
    /* ================= æ–°å¢ç‰¹æ•ˆï¼šèƒŒæ™¯åŠ¨æ€æ¸å˜ ================= */
    @keyframes backgroundShift {
        0%, 100% {
            background: radial-gradient(ellipse at center, rgba(5, 5, 5, 1) 0%, rgba(10, 5, 15, 1) 100%);
        }
        50% {
            background: radial-gradient(ellipse at center, rgba(10, 5, 15, 1) 0%, rgba(5, 5, 5, 1) 100%);
        }
    }
    
    body {
        animation: backgroundShift 20s ease-in-out infinite;
    }
    
    /* ================= æ–°å¢ç‰¹æ•ˆï¼šåŠ è½½å™¨å¢å¼º ================= */
    @keyframes loaderPulse {
        0%, 100% {
            opacity: 0.8;
            transform: scale(1);
        }
        50% {
            opacity: 1;
            transform: scale(1.1);
        }
    }
    
    .loader-text {
        animation: loaderPulse 2s ease-in-out infinite;
    }
    
    /* ================= æ–°å¢ç‰¹æ•ˆï¼šæ»‘å—å¢å¼º ================= */
    input[type=range]::-webkit-slider-runnable-track {
        background: linear-gradient(90deg, 
            rgba(255, 255, 255, 0.1) 0%, 
            rgba(212, 175, 55, 0.3) 50%, 
            rgba(255, 255, 255, 0.1) 100%);
        box-shadow: 0 0 5px rgba(212, 175, 55, 0.2);
    }
    
    input[type=range]:active::-webkit-slider-thumb {
        transform: scale(1.5);
        box-shadow: 0 0 15px rgba(212, 175, 55, 1);
    }
    
    /* ================= æ–°å¢ç‰¹æ•ˆï¼šè¾“å…¥æ¡†èšç„¦å¢å¼º ================= */
    .input-glass:focus {
        box-shadow: 0 0 10px rgba(212, 175, 55, 0.5),
                    inset 0 0 10px rgba(212, 175, 55, 0.1);
        transform: scale(1.02);
    }
    
    /* ================= æ–°å¢ç‰¹æ•ˆï¼šåˆ é™¤æŒ‰é’®åŠ¨ç”» ================= */
    @keyframes deleteShake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-3px) rotate(-5deg); }
        75% { transform: translateX(3px) rotate(5deg); }
    }
    
    .delete-x:hover {
        animation: deleteShake 0.3s ease-in-out;
        background: #c00;
        transform: scale(1.2);
    }
</style>
<!-- å¾®ä¿¡å…¼å®¹ï¼šä½¿ç”¨UMDç‰ˆæœ¬çš„Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<!-- åå¤„ç†æ‰©å±•åº“ï¼ˆå¯é€‰ï¼Œå¦‚æœåŠ è½½å¤±è´¥ä¸å½±å“ä¸»åŠŸèƒ½ï¼‰ -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js" onerror="console.warn('EffectComposeråŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨æ™®é€šæ¸²æŸ“')"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js" onerror="console.warn('RenderPassåŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨æ™®é€šæ¸²æŸ“')"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js" onerror="console.warn('UnrealBloomPassåŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨æ™®é€šæ¸²æŸ“')"></script>
<!-- RoomEnvironment å¯é€‰åŠ è½½ï¼Œå¦‚æœå¤±è´¥ä¸å½±å“ä¸»åŠŸèƒ½ -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/environments/RoomEnvironment.js" onerror="console.warn('RoomEnvironmentåŠ è½½å¤±è´¥ï¼Œå°†è·³è¿‡ç¯å¢ƒè®¾ç½®')"></script>
</head><body><div id="loader"><div class="spinner"></div><div class="loader-text">SYSTEM INITIALIZING</div></div><div id="canvas-container"></div><div id="title-container"><h1 id="display-line1" class="title-line">Merry</h1><h1 id="display-line2" class="title-line">Christmas</h1></div><div id="mode-switch-indicator" class="mode-switch-indicator"></div><div id="ui-layer"><div id="top-right-controls"><button class="elegant-btn glass-panel" id="fs-btn" onclick="toggleFullScreen()" style="padding: 6px 12px;">â›¶ å…¨å±æ˜¾ç¤º</button><button class="elegant-btn glass-panel" id="toggle-ui-btn" onclick="toggleUI()" style="padding: 6px 12px;">ğŸ‘ éšè—ç•Œé¢</button></div><div id="left-sidebar"><div class="top-left-panel glass-panel"><div class="ui-title-main">åœºæ™¯å®šåˆ¶</div> 
            <div class="ui-title-sub">ç¥ç¦è¯­å½•</div><div class="control-row"><input type="text" id="input-line1" class="input-glass" placeholder="ç¬¬ä¸€è¡Œæ–‡å­—" oninput="updateTextConfig()"><input type="text" id="input-line2" class="input-glass" placeholder="ç¬¬äºŒè¡Œæ–‡å­—" oninput="updateTextConfig()" style="margin-top:2px;"></div><div class="ui-title-sub">å­—ä½“é£æ ¼</div><select id="font-select" class="input-glass" onchange="updateTextConfig()"><option value="style1">ä¹¦æ³•éŸµå‘³</option><option value="style2">å¤å…¸è¡¬çº¿</option><option value="style3">ä¼˜é›…æ‰‹å†™</option><option value="style4">è‰ºæœ¯çº¿æ¡</option><option value="style5">å¤å¤é‡ç£…</option></select><div class="control-row"><div class="ui-title-sub" style="margin-top:6px;">å¤§å° & é¢œè‰²</div><div style="display:flex; gap:8px; align-items:center;"><input type="range" min="50" max="250" value="100" id="slider-fontsize" oninput="updateTextConfig()"><input type="color" id="color-picker" value="#fceea7" oninput="updateTextConfig()" style="width:30px; height:20px; border:none;"></div></div><div class="ui-title-sub" style="border-top:1px solid rgba(255,255,255,0.05); padding-top:6px; margin-top:6px;">èƒŒæ™¯éŸ³ä¹</div><div style="display:flex; gap:8px; margin-bottom:4px;"><button class="elegant-btn" onclick="toggleMusicPlay()" id="play-btn" style="flex:2; font-size:14px;">â¯</button><button class="elegant-btn" onclick="replayMusic()" style="flex:1; font-size:14px;">âŸ²</button></div><div class="control-row"><span class="control-label" style="text-align:center;">éŸ³é‡è°ƒèŠ‚</span><input type="range" min="0" max="100" value="50" id="slider-volume" oninput="updateVolume(this.value)"></div><div class="ui-title-sub" style="border-top:1px solid rgba(255,255,255,0.05); padding-top:6px; margin-top:6px;">ç²’å­æ§åˆ¶</div><div class="particle-scroll-container"><div class="control-row"><span class="control-label">è£…é¥°å¯†åº¦ (æ ‘)</span><input type="range" min="500" max="3000" value="1500" id="slider-tree"></div><div class="control-row"><span class="control-label">æ˜Ÿå°˜å¯†åº¦ (èƒŒæ™¯)</span><input type="range" min="500" max="5000" value="2500" id="slider-dust"></div><div class="control-row"><span class="control-label">é›ªèŠ±æ•°é‡</span><input type="range" min="0" max="3000" step="100" value="1500" id="slider-snow-count" onchange="updateSnowSettings()"></div><div class="control-row"><span class="control-label">é›ªèŠ±å¤§å°</span><input type="range" min="0.05" max="0.3" step="0.01" value="0.12" id="slider-snow-size" onchange="updateSnowSettings()"></div><div class="control-row"><span class="control-label">ä¸‹è½é€Ÿåº¦</span><input type="range" min="1.0" max="8.0" step="0.5" value="3.5" id="slider-snow-speed" oninput="updateSnowSpeed(this.value)"></div></div><button class="elegant-btn" style="width:100%; margin-top:8px;" onclick="applyParticleSettings()">âš¡ é‡ç½®åœºæ™¯</button></div><div class="top-left-panel glass-panel"><div class="ui-title-main">äº¤äº’ä¸­æ§</div><div class="ui-title-sub">å½¢æ€åˆ‡æ¢</div><div class="interaction-grid"><button class="elegant-btn" style="flex:1;" onclick="setMode('TREE')">èšåˆ (Space)</button><button class="elegant-btn" style="flex:1;" onclick="setMode('SCATTER')">æ•£å¼€ (Z)</button></div><button class="elegant-btn" style="width:100%;" onclick="triggerPhotoGrab()">æŠ“å–ç…§ç‰‡ (X)</button><div class="control-row" style="margin-top:8px;"><span class="control-label">æ—‹è½¬é€Ÿåº¦ (æ•£å¼€)</span><input type="range" min="0.1" max="5.0" step="0.1" value="1.4" oninput="updateRotationSpeed(this.value)"></div><div class="direction-pad"><div></div><div class="dir-btn" onmousedown="startRotate('up')" onmouseup="stopRotate()" onmouseleave="stopRotate()">â–²</div><div></div><div class="dir-btn" onmousedown="startRotate('left')" onmouseup="stopRotate()" onmouseleave="stopRotate()">â—€</div><div class="dir-btn" onclick="resetRotation()" style="font-size:10px;">â—</div><div class="dir-btn" onmousedown="startRotate('right')" onmouseup="stopRotate()" onmouseleave="stopRotate()">â–¶</div><div></div><div class="dir-btn" onmousedown="startRotate('down')" onmouseup="stopRotate()" onmouseleave="stopRotate()">â–¼</div><div></div></div></div></div><div class="bottom-left-panel glass-panel"><div class="ui-title-main" style="font-size:12px; margin-bottom:5px;">èµ„æºç®¡ç†</div><label class="elegant-btn"> + ä¸Šä¼ ç…§ç‰‡ <input type="file" id="file-input" multiple accept="image/*"> </label><button class="elegant-btn" onclick="openDeleteManager()">â–£ ç®¡ç†ç…§ç‰‡</button><label class="elegant-btn" id="music-upload-label"> â™« èƒŒæ™¯éŸ³ä¹ <input type="file" id="music-input" accept=".mp3,audio/mpeg"> </label><button class="elegant-btn" id="toggle-cam-btn" onclick="toggleCameraDisplay()">ğŸ“· éšè—ç”»é¢</button></div></div><div id="gesture-hint">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</div><div id="webcam-wrapper"><canvas id="webcam-canvas" width="320" height="240"></canvas><div id="cam-status"></div></div><video id="webcam-video" autoplay playsinline muted style="display:none"></video><div id="delete-manager" class="hidden"><div class="manager-title">ç…§ç‰‡åº“ç®¡ç†</div><div id="photo-grid"></div><div class="manager-actions"><button class="elegant-btn btn-red glass-panel" onclick="clearAllPhotos()" style="padding: 8px 20px;">æ¸…ç©ºæ‰€æœ‰</button><button class="elegant-btn glass-panel" onclick="closeDeleteManager()" style="padding: 8px 20px;">å…³é—­</button></div></div>
<script>
    // å¾®ä¿¡æµè§ˆå™¨æ£€æµ‹
    const isWeChat = /MicroMessenger/i.test(navigator.userAgent);
    
    // æ£€æŸ¥Three.jsæ˜¯å¦åŠ è½½æˆåŠŸ
    if(typeof THREE === 'undefined') {
        document.getElementById('loader').innerHTML = '<div style="color:#d4af37; text-align:center; padding:20px;">åŠ è½½å¤±è´¥ï¼šè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥<br/>Three.jsåº“æ— æ³•åŠ è½½</div>';
    }
    
    // ä½¿ç”¨å…¨å±€THREEå¯¹è±¡ï¼ˆå¾®ä¿¡å…¼å®¹ï¼‰
    const THREE_Global = typeof THREE !== 'undefined' ? THREE : null;
    
    if(!THREE_Global) {
        throw new Error('Three.jsæœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
    }

    // Clean Database Nameconst DB_NAME = "GrandTreeDB_v17_Clean"; 
    const EXPORTED_DATA = null;

    let CONFIG = {
        colors: { bg: 0x000000, champagneGold: 0xffd966, deepGreen: 0x03180a, accentRed: 0x990000 },
        particles: { count: 1500, dustCount: 2500, treeHeight: 24, treeRadius: 8 },
        snow: { count: 1500, range: 70, speed: 3.5, sizeBase: 0.12, sizeVar: 0.1 }, 
        camera: { z: 50 },
        interaction: { rotationSpeed: 1.4, grabRadius: 0.25 }
    };

    const STATE = { mode: 'TREE', focusTarget: null, focusType: 0, hand: { detected: false, x: 0, y: 0 }, rotation: { x: 0, y: 0 }, uiVisible: true, cameraVisible: true };
    let manualRotateState = { x: 0, y: 0 };
    const FONT_STYLES = { 'style1': { font: "'Ma Shan Zheng', cursive", spacing: "4px", shadow: "2px 2px 8px rgba(180,50,50,0.8)", transform: "none" }, 'style2': { font: "'Cinzel', serif", spacing: "6px", shadow: "0 0 20px rgba(255,215,0,0.5)", transform: "none" }, 'style3': { font: "'Great Vibes', cursive", spacing: "1px", shadow: "0 0 15px rgba(255,200,255,0.7)", transform: "none" }, 'style4': { font: "'Monoton', cursive", spacing: "1px", shadow: "0 0 10px #fff", transform: "none" }, 'style5': { font: "'Abril Fatface', cursive", spacing: "0px", shadow: "0 5px 15px rgba(0,0,0,0.8)", transform: "none" } };

    let db;
    function initDB() { if(EXPORTED_DATA) return Promise.resolve(null); return new Promise(r=>{const q=indexedDB.open(DB_NAME,1);q.onupgradeneeded=e=>{const d=e.target.result;if(!d.objectStoreNames.contains('photos'))d.createObjectStore('photos',{keyPath:"id"});if(!d.objectStoreNames.contains('music'))d.createObjectStore('music',{keyPath:"id"})};q.onsuccess=e=>{db=e.target.result;r(db)};q.onerror=()=>r(null)});}
    function savePhotoToDB(b){if(!db)return null;const t=db.transaction('photos',"readwrite");const i=Date.now()+Math.random().toString();t.objectStore('photos').add({id:i,data:b});return i;}
    function loadPhotosFromDB(){if(EXPORTED_DATA) return Promise.resolve(EXPORTED_DATA.photos || []); if(!db)return Promise.resolve([]); return new Promise(r=>{db.transaction('photos',"readonly").objectStore('photos').getAll().onsuccess=e=>r(e.target.result)});}
    function deletePhotoFromDB(i){if(db)db.transaction('photos',"readwrite").objectStore('photos').delete(i);}
    function clearPhotosDB(){if(db)db.transaction('photos',"readwrite").objectStore('photos').clear();}
    function saveMusicToDB(b){if(!db)return;const t=db.transaction('music',"readwrite");t.objectStore('music').put({id:'bgm',data:b});}
    function loadMusicFromDB(){if(EXPORTED_DATA && EXPORTED_DATA.music) return Promise.resolve(dataURLtoBlob(EXPORTED_DATA.music)); if(!db)return Promise.resolve(null);return new Promise(r=>{db.transaction('music',"readonly").objectStore('music').get('bgm').onsuccess=e=>r(e.target.result?e.target.result.data:null)});}
    function dataURLtoBlob(dataurl) { var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--){ u8arr[n] = bstr.charCodeAt(n); } return new Blob([u8arr], {type:mime}); }

    let scene, camera, renderer, composer, mainGroup, particleSystem=[], photoMeshGroup=new THREE.Group(), snowInstancedMesh, snowDummy=new THREE.Object3D(), snowData=[], clock=new THREE.Clock(), handLandmarker, videoElement, caneTexture, bgmAudio=new Audio(); bgmAudio.loop=true; let isMusicPlaying=false;

    /**
     * éšè—åŠ è½½å™¨
     */
    function hideLoader() {
        const loader = document.getElementById('loader');
        if(loader) { 
            loader.style.opacity = 0; 
            setTimeout(() => loader.remove(), 500); 
        }
    }

    /**
     * æ›´æ–°åŠ è½½å™¨æ–‡æœ¬
     */
    function updateLoaderText(text) {
        const loaderText = document.querySelector('.loader-text');
        if(loaderText) loaderText.textContent = text;
    }

    async function init() {
        try {
            updateLoaderText('åŠ è½½ä¸­...');
            
        if (EXPORTED_DATA) {
            document.body.classList.add('exported-mode');
            CONFIG = EXPORTED_DATA.config;
            setTimeout(() => applyTextConfig(EXPORTED_DATA.text.fontKey, EXPORTED_DATA.text.line1, EXPORTED_DATA.text.line2, EXPORTED_DATA.text.size, EXPORTED_DATA.text.color), 100);
        }

            updateLoaderText('åˆå§‹åŒ–3Dåœºæ™¯...');
            initThree(); 
            setupEnvironment(); 
            setupLights(); 
            createTextures(); 
            createParticles(); 
            createDust(); 
            createSnow(); 
            createDefaultPhotos(); 
            setupPostProcessing(); 
            setupEvents(); 
            animate();
            
            // å…ˆéšè—loaderï¼Œè®©ç”¨æˆ·çœ‹åˆ°åœºæ™¯
            hideLoader();

            updateLoaderText('åŠ è½½æ•°æ®...');
        try {
            await initDB();
            if(!EXPORTED_DATA) loadTextConfig();
            
                const ps = await loadPhotosFromDB(); 
                if(ps?.length > 0){ 
                    photoMeshGroup.clear(); 
                    particleSystem = particleSystem.filter(p => p.type !== 'PHOTO'); 
                    ps.forEach(i => createPhotoTexture(i.data, i.id)); 
                } 
                
                const ms = await loadMusicFromDB(); 
                if(ms){ 
                    // é‡Šæ”¾æ—§çš„ URL å¯¹è±¡ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
                    if (bgmAudio.src && bgmAudio.src.startsWith('blob:')) {
                        URL.revokeObjectURL(bgmAudio.src);
                    }
                    bgmAudio.src = URL.createObjectURL(ms); 
                    if(EXPORTED_DATA) { 
                        document.body.addEventListener('click', () => { 
                            if(!isMusicPlaying) toggleMusicPlay(); 
                        }, { once: true }); 
                    } 
                    updatePlayBtnUI(false); 
                } 
            } catch(e){
                console.warn('æ•°æ®åº“åŠ è½½å¤±è´¥:', e);
            }
            
            // MediaPipeåˆå§‹åŒ–å¤±è´¥ä¸å½±å“ä¸»ç¨‹åº
            try {
                updateLoaderText('åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«...');
                await initMediaPipe();
            } catch(e) {
                console.warn('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥ï¼ˆéœ€è¦ç½‘ç»œè¿æ¥ï¼‰:', e);
                updateLoaderText('æ‰‹åŠ¿è¯†åˆ«ä¸å¯ç”¨');
            }
            
            initDraggableTitle();
            setMode('TREE');
            
            // æ›´æ–°æç¤ºæ–‡æœ¬
            const hint = document.getElementById('gesture-hint');
            if(hint) hint.innerText = "ç³»ç»Ÿå°±ç»ªï¼æŒ‰ H é”®éšè—/æ˜¾ç¤ºç•Œé¢";
            
            // æ ‡è®°åˆå§‹åŒ–å®Œæˆ
            initCompleted = true;
            
        } catch(error) {
            console.error('åˆå§‹åŒ–å¤±è´¥:', error);
            updateLoaderText('åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°');
            // å³ä½¿å‡ºé”™ä¹Ÿè¦éšè—loader
            setTimeout(() => {
                hideLoader();
                alert('åˆå§‹åŒ–å¤±è´¥ï¼š' + error.message + '\n\nè¯·ç¡®ä¿ï¼š\n1. å·²è¿æ¥ç½‘ç»œï¼ˆéœ€è¦åŠ è½½Three.jsåº“ï¼‰\n2. ä½¿ç”¨ç°ä»£æµè§ˆå™¨ï¼ˆChrome/Edge/Firefoxï¼‰\n3. æŸ¥çœ‹æ§åˆ¶å°è·å–è¯¦ç»†é”™è¯¯ä¿¡æ¯');
            }, 2000);
        }
    }
    
    // å…¨å±€é”™è¯¯å¤„ç†ï¼šç¡®ä¿loaderä¸€å®šä¼šéšè—
    let initCompleted = false;
    window.addEventListener('error', (e) => {
        console.error('å…¨å±€é”™è¯¯:', e.error);
        if(!initCompleted) {
            setTimeout(hideLoader, 1000);
        }
    });
    
    // æœªæ•è·çš„Promiseé”™è¯¯å¤„ç†
    window.addEventListener('unhandledrejection', (e) => {
        console.error('æœªå¤„ç†çš„Promiseé”™è¯¯:', e.reason);
        if(!initCompleted) {
            setTimeout(hideLoader, 1000);
        }
    });

    /**
     * åˆå§‹åŒ–å¯æ‹–æ‹½æ ‡é¢˜
     */
    function initDraggableTitle() { 
        const titleContainer = document.getElementById('title-container');
        if(!titleContainer) return; // å®‰å…¨æ£€æŸ¥
        
        let isDragging = false;
        let offset = {x: 0, y: 0};
        
        titleContainer.onmousedown = (e) => {
            isDragging = true;
            const rect = titleContainer.getBoundingClientRect();
            offset.x = e.clientX - rect.left;
            offset.y = e.clientY - rect.top;
            titleContainer.style.transform = 'none';
            titleContainer.style.left = rect.left + 'px';
            titleContainer.style.top = rect.top + 'px';
        };
        
        window.onmousemove = (e) => {
            if(isDragging) {
                titleContainer.style.left = (e.clientX - offset.x) + 'px';
                titleContainer.style.top = (e.clientY - offset.y) + 'px';
            }
        };
        
        window.onmouseup = () => {
            isDragging = false;
        };
    }
    window.toggleUI = () => { 
        STATE.uiVisible = !STATE.uiVisible; 
        const sidebar = document.getElementById('left-sidebar');
        const bottomPanel = document.querySelector('.bottom-left-panel');
        if(sidebar) sidebar.classList.toggle('panel-hidden', !STATE.uiVisible);
        if(bottomPanel) bottomPanel.classList.toggle('panel-hidden', !STATE.uiVisible);
    };
    
    window.toggleCameraDisplay = () => { 
        STATE.cameraVisible = !STATE.cameraVisible; 
        const webcamWrapper = document.getElementById('webcam-wrapper');
        if(webcamWrapper) webcamWrapper.classList.toggle('camera-hidden', !STATE.cameraVisible);
    };
    
    window.toggleFullScreen = () => { 
        if(!document.fullscreenElement) {
            const elem = document.documentElement;
            if(elem.requestFullscreen) elem.requestFullscreen();
            else if(elem.webkitRequestFullscreen) elem.webkitRequestFullscreen(); // Safari
            else if(elem.msRequestFullscreen) elem.msRequestFullscreen(); // IE/Edge
        } else {
            if(document.exitFullscreen) document.exitFullscreen();
            else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
            else if(document.msExitFullscreen) document.msExitFullscreen();
        }
    };
    function loadTextConfig() { const s=JSON.parse(localStorage.getItem('v16_text_config')); if(s){ document.getElementById('input-line1').value=s.line1||""; document.getElementById('input-line2').value=s.line2||""; document.getElementById('font-select').value=s.fontKey||"style1"; document.getElementById('slider-fontsize').value=s.size||100; document.getElementById('color-picker').value=s.color||"#fceea7"; applyTextConfig(s.fontKey,s.line1,s.line2,s.size,s.color); } else { document.getElementById('input-line1').value="Merry"; document.getElementById('input-line2').value="Christmas"; applyTextConfig("style1","Merry","Christmas",100,"#fceea7"); } }
    window.updateTextConfig=()=> { const k=document.getElementById('font-select').value, l1=document.getElementById('input-line1').value, l2=document.getElementById('input-line2').value, s=document.getElementById('slider-fontsize').value, c=document.getElementById('color-picker').value; localStorage.setItem('v16_text_config',JSON.stringify({fontKey:k,line1:l1,line2:l2,size:s,color:c})); applyTextConfig(k,l1,l2,s,c); };
    function applyTextConfig(k,l1,l2,s,c) { const st=FONT_STYLES[k]||FONT_STYLES['style1']; const t1=document.getElementById('display-line1'), t2=document.getElementById('display-line2'), ct=document.getElementById('title-container'); ct.style.fontFamily=st.font; t1.innerText=l1; t2.innerText=l2; t1.style.letterSpacing=st.spacing; t2.style.letterSpacing=st.spacing; t1.style.textShadow=st.shadow; t2.style.textShadow=st.shadow; t1.style.textTransform=st.transform; t2.style.textTransform=st.transform; t1.style.color=c; t2.style.color=c; t1.style.fontSize=(0.48*s)+"px"; t2.style.fontSize=(0.48*s)+"px"; }
    
    /**
     * æ˜¾ç¤ºæç¤ºæ¶ˆæ¯ï¼ˆå¢å¼ºç‰ˆï¼šæ›´å¥½çš„åŠ¨ç”»æ•ˆæœï¼‰
     */
    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        const colors = {
            info: { bg: 'rgba(212,175,55,0.95)', color: '#000', border: '#d4af37' },
            success: { bg: 'rgba(76,175,80,0.95)', color: '#fff', border: '#4caf50' },
            error: { bg: 'rgba(244,67,54,0.95)', color: '#fff', border: '#f44336' }
        };
        const style = colors[type] || colors.info;
        
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${style.bg};
            color: ${style.color};
            padding: 14px 24px;
            border-radius: 8px;
            z-index: 10000;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4),
                        0 0 20px ${style.border}40,
                        inset 0 1px 0 rgba(255,255,255,0.2);
            border: 1px solid ${style.border};
            backdrop-filter: blur(10px);
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            max-width: 300px;
            word-wrap: break-word;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);
        
        // æ»‘å…¥åŠ¨ç”»
        requestAnimationFrame(() => {
            toast.style.transform = 'translateX(0)';
            toast.style.opacity = '1';
        });
        
        // è‡ªåŠ¨ç§»é™¤
        setTimeout(() => {
            toast.style.transform = 'translateX(400px)';
            toast.style.opacity = '0';
            setTimeout(() => toast.remove(), 400);
        }, 3000);
    }
    
    window.toggleMusicPlay=()=> { 
        if(!bgmAudio.src) { 
            showToast("è¯·å…ˆä¸Šä¼ éŸ³ä¹", 'info'); 
            return; 
        } 
        if(isMusicPlaying){ 
            bgmAudio.pause(); 
            isMusicPlaying=false; 
        } else { 
            bgmAudio.play().catch(() => showToast("éŸ³ä¹æ’­æ”¾å¤±è´¥", 'error')); 
            isMusicPlaying=true; 
        } 
        updatePlayBtnUI(isMusicPlaying); 
    };
    window.replayMusic=()=> { if(!bgmAudio.src) return; bgmAudio.currentTime=0; bgmAudio.play(); isMusicPlaying=true; updatePlayBtnUI(true); };
    window.updateVolume=(v)=> { bgmAudio.volume=v/100; };
    function updatePlayBtnUI(p) { document.getElementById('play-btn').innerText = p ? "â¸" : "â¯"; }

    window.updateRotationSpeed=(v)=> { CONFIG.interaction.rotationSpeed = parseFloat(v); };
    
    /**
     * æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢è§†è§‰åé¦ˆ
     */
    function showModeSwitchIndicator(text) {
        const indicator = document.getElementById('mode-switch-indicator');
        if(!indicator) return;
        
        indicator.textContent = text;
        indicator.classList.add('show');
        
        setTimeout(() => {
            indicator.classList.remove('show');
        }, 1000);
    }
    
    window.setMode = function(mode) {
        STATE.mode = mode;
        STATE.focusTarget = null;
        const hint = document.getElementById('gesture-hint');
        
        // æ¨¡å¼åˆ‡æ¢è§†è§‰åé¦ˆ
        if(mode === 'TREE') {
            hint.innerText = "çŠ¶æ€: èšåˆ (åœ£è¯æ ‘)";
            showModeSwitchIndicator('ğŸŒ² èšåˆæ¨¡å¼');
        } else if(mode === 'SCATTER') {
            hint.innerText = "çŠ¶æ€: æ•£å¼€ (æ˜Ÿäº‘)";
            showModeSwitchIndicator('âœ¨ æ•£å¼€æ¨¡å¼');
        } else if(mode === 'FOCUS') {
            hint.innerText = "çŠ¶æ€: æŠ“å–ç…§ç‰‡";
            showModeSwitchIndicator('ğŸ“¸ ç„¦ç‚¹æ¨¡å¼');
        }
        
        // æ·»åŠ åœºæ™¯åˆ‡æ¢çš„è§†è§‰å†²å‡»æ•ˆæœ
        if(scene && camera) {
            // è½»å¾®çš„ç›¸æœºéœ‡åŠ¨æ•ˆæœ
            const originalZ = camera.position.z;
            camera.position.z = originalZ + 0.5;
            setTimeout(() => {
                camera.position.z = originalZ;
            }, 200);
        }
    }

    /**
     * è§¦å‘ç…§ç‰‡æŠ“å–ï¼šæ‰¾åˆ°å±å¹•ä¸­å¿ƒæœ€è¿‘çš„ç…§ç‰‡å¹¶èšç„¦
     */
    window.triggerPhotoGrab = () => { 
        let closestPhoto = null;
        let minDistance = Infinity; 
        
        // éšæœºé€‰æ‹©ä¸€ç§ç„¦ç‚¹æ˜¾ç¤ºç±»å‹
        STATE.focusType = Math.floor(Math.random() * 4); 
        
        // éå†æ‰€æœ‰ç…§ç‰‡ç²’å­ï¼Œæ‰¾åˆ°å±å¹•ä¸­å¿ƒæœ€è¿‘çš„
        particleSystem.filter(p => p.type === 'PHOTO').forEach(particle => { 
            particle.mesh.updateMatrixWorld(); 
            const worldPos = new THREE.Vector3(); 
            particle.mesh.getWorldPosition(worldPos); 
            
            // å°†3Dä½ç½®æŠ•å½±åˆ°å±å¹•åæ ‡
            const screenPos = worldPos.project(camera); 
            const distanceFromCenter = Math.hypot(screenPos.x, screenPos.y); 
            
            // æ£€æŸ¥æ˜¯å¦åœ¨å±å¹•å†…ä¸”è·ç¦»ä¸­å¿ƒè¶³å¤Ÿè¿‘
            if(screenPos.z < 1 && distanceFromCenter < CONFIG.interaction.grabRadius){
                if(distanceFromCenter < minDistance){
                    minDistance = distanceFromCenter;
                    closestPhoto = particle.mesh;
                }
            } 
        }); 
        
        if(closestPhoto){
            setMode('FOCUS'); 
            STATE.focusTarget = closestPhoto; 
        } else {
            setMode('SCATTER');
        }
    };
    
    window.startRotate=(d)=> { if(d==='up')manualRotateState.x=-1; if(d==='down')manualRotateState.x=1; if(d==='left')manualRotateState.y=-1; if(d==='right')manualRotateState.y=1; };
    window.stopRotate=()=> { manualRotateState={x:0,y:0}; };
    window.resetRotation=()=> { STATE.rotation={x:0,y:0}; if(STATE.mode!=='TREE')setMode('TREE'); };

    // ================= V17.6.5: UI + Keyboard =================
    let resizeTimer;
    window.setupEvents = function() {
        // é˜²æŠ–ä¼˜åŒ–ï¼šresize äº‹ä»¶å»¶è¿Ÿæ‰§è¡Œï¼Œé¿å…é¢‘ç¹è°ƒç”¨
        window.addEventListener('resize', () => { 
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
            camera.aspect = window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            // å¦‚æœåå¤„ç†å¯ç”¨ï¼Œä¹Ÿæ›´æ–°å…¶å°ºå¯¸
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
            }, 100);
        });
        
        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files; 
            if(!files.length) return;
            
            const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
            const MAX_FILES = 10;
            const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
            
            if (files.length > MAX_FILES) {
                showToast(`æœ€å¤šåªèƒ½ä¸Šä¼ ${MAX_FILES}å¼ ç…§ç‰‡`, 'error');
                e.target.value = '';
                return;
            }
            
            let successCount = 0;
            Array.from(files).forEach(f => {
                // æ–‡ä»¶å¤§å°æ£€æŸ¥
                if (f.size > MAX_FILE_SIZE) {
                    showToast(`æ–‡ä»¶ ${f.name} è¶…è¿‡5MBé™åˆ¶`, 'error');
                    return;
                }
                
                // æ–‡ä»¶ç±»å‹æ£€æŸ¥
                if (!ALLOWED_TYPES.includes(f.type)) {
                    showToast(`æ–‡ä»¶ ${f.name} æ ¼å¼ä¸æ”¯æŒ`, 'error');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const base64 = ev.target.result;
                        const id = savePhotoToDB(base64);
                        if (id) {
                            createPhotoTexture(base64, id);
                            successCount++;
                            // å»¶è¿Ÿæ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯ï¼Œç­‰å¾…æ‰€æœ‰æ–‡ä»¶å¤„ç†å®Œæˆ
                            setTimeout(() => {
                                if(successCount === Array.from(files).filter(f => 
                                    f.size <= MAX_FILE_SIZE && ALLOWED_TYPES.includes(f.type)
                                ).length) {
                                    showToast(`æˆåŠŸä¸Šä¼  ${successCount} å¼ ç…§ç‰‡`, 'success');
                                }
                            }, 500);
                        } else {
                            showToast('ç…§ç‰‡ä¿å­˜å¤±è´¥', 'error');
                        }
                    } catch (error) {
                        console.error('å¤„ç†ç…§ç‰‡å¤±è´¥:', error);
                        showToast('ç…§ç‰‡å¤„ç†å¤±è´¥', 'error');
                    }
                };
                reader.onerror = () => {
                    showToast(`è¯»å–æ–‡ä»¶ ${f.name} å¤±è´¥`, 'error');
                };
                reader.readAsDataURL(f);
            });
            e.target.value = ''; // æ¸…ç©ºinputï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
        });
        document.getElementById('music-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const MAX_MUSIC_SIZE = 20 * 1024 * 1024; // 20MB
                const ALLOWED_MUSIC_TYPES = ['audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/ogg'];
                
                // æ–‡ä»¶å¤§å°æ£€æŸ¥
                if (file.size > MAX_MUSIC_SIZE) {
                    showToast('éŸ³ä¹æ–‡ä»¶è¶…è¿‡20MBé™åˆ¶', 'error');
                    e.target.value = '';
                    return;
                }
                
                // æ–‡ä»¶ç±»å‹æ£€æŸ¥
                if (!ALLOWED_MUSIC_TYPES.includes(file.type) && !file.name.match(/\.(mp3|wav|ogg)$/i)) {
                    showToast('ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼ï¼Œè¯·ä½¿ç”¨ MP3/WAV/OGG', 'error');
                    e.target.value = '';
                    return;
                }
                
                try {
                    // é‡Šæ”¾æ—§çš„ URL å¯¹è±¡ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
                    if (bgmAudio.src && bgmAudio.src.startsWith('blob:')) {
                        URL.revokeObjectURL(bgmAudio.src);
                    }
                    saveMusicToDB(file);
                    bgmAudio.src = URL.createObjectURL(file);
                    bgmAudio.play().then(() => { 
                        isMusicPlaying = true; 
                        updatePlayBtnUI(true);
                        showToast('éŸ³ä¹åŠ è½½æˆåŠŸ', 'success');
                    }).catch((error) => {
                        console.error('éŸ³ä¹æ’­æ”¾å¤±è´¥:', error);
                        showToast('éŸ³ä¹æ’­æ”¾å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼', 'error');
                        isMusicPlaying = false;
                        updatePlayBtnUI(false);
                    });
                } catch (error) {
                    console.error('å¤„ç†éŸ³ä¹æ–‡ä»¶å¤±è´¥:', error);
                    showToast('éŸ³ä¹æ–‡ä»¶å¤„ç†å¤±è´¥', 'error');
                    e.target.value = '';
                }
            }
        });

        // --- Keyboard Controls ---
        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            const k = e.key.toLowerCase();
            const code = e.code;

            if (k === 'h') window.toggleUI();

            if (code === 'Space') { e.preventDefault(); setMode('TREE'); }
            if (k === 'z') setMode('SCATTER');
            if (k === 'x') triggerPhotoGrab();

            if (code === 'ArrowUp') manualRotateState.x = -1;
            if (code === 'ArrowDown') manualRotateState.x = 1;
            if (code === 'ArrowLeft') manualRotateState.y = -1;
            if (code === 'ArrowRight') manualRotateState.y = 1;
        });

        window.addEventListener('keyup', (e) => {
            const code = e.code;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(code)) {
                manualRotateState = { x: 0, y: 0 };
            }
        });
    }

    function initThree() { const c=document.getElementById('canvas-container'); scene=new THREE.Scene(); scene.background=new THREE.Color(CONFIG.colors.bg); scene.fog=new THREE.FogExp2(CONFIG.colors.bg,0.01); camera=new THREE.PerspectiveCamera(42,window.innerWidth/window.innerHeight,0.1,1000); camera.position.set(0,2,CONFIG.camera.z); renderer=new THREE.WebGLRenderer({antialias:true,alpha:false,powerPreference:"high-performance"}); renderer.setSize(window.innerWidth,window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)); renderer.toneMapping=THREE.ReinhardToneMapping; renderer.toneMappingExposure=2.2; c.appendChild(renderer.domElement); mainGroup=new THREE.Group(); scene.add(mainGroup); }
    function setupEnvironment() { 
        try {
            // æ£€æŸ¥RoomEnvironmentæ˜¯å¦å¯ç”¨
            if (typeof RoomEnvironment !== 'undefined') {
                const p = new THREE.PMREMGenerator(renderer);
                scene.environment = p.fromScene(new RoomEnvironment(), 0.04).texture;
            } else {
                // RoomEnvironmentä¸å¯ç”¨ï¼Œè·³è¿‡ç¯å¢ƒè®¾ç½®ï¼ˆä¸å½±å“å…¶ä»–åŠŸèƒ½ï¼‰
                console.log('RoomEnvironmentä¸å¯ç”¨ï¼Œè·³è¿‡ç¯å¢ƒè´´å›¾è®¾ç½®');
            }
        } catch (error) {
            console.warn('ç¯å¢ƒè®¾ç½®å¤±è´¥:', error.message);
            // ç»§ç»­æ‰§è¡Œï¼Œä¸å½±å“ä¸»åŠŸèƒ½
        }
    }
    /**
     * è®¾ç½®åœºæ™¯å…‰ç…§ï¼ˆå¢å¼ºç‰ˆï¼šæ·»åŠ åŠ¨æ€å…‰æ•ˆï¼‰
     */
    let dynamicLights = [];
    function setupLights() { 
        // ç¯å¢ƒå…‰
        scene.add(new THREE.AmbientLight(0xffffff, 0.6)); 
        
        // ä¸­å¿ƒç‚¹å…‰æºï¼ˆé‡‘è‰²ï¼Œå¯åŠ¨æ€å˜åŒ–ï¼‰
        const centerLight = new THREE.PointLight(0xffaa00, 2, 20); 
        centerLight.position.set(0, 5, 0); 
        mainGroup.add(centerLight);
        dynamicLights.push({light: centerLight, baseIntensity: 2, color: 0xffaa00});
        
        // èšå…‰ç¯1ï¼ˆæš–é‡‘è‰²ï¼‰
        const spotLight1 = new THREE.SpotLight(0xffcc66, 1200); 
        spotLight1.position.set(30, 40, 40); 
        spotLight1.angle = 0.5; 
        spotLight1.penumbra = 0.5;
        spotLight1.castShadow = true;
        scene.add(spotLight1);
        dynamicLights.push({light: spotLight1, baseIntensity: 1200, color: 0xffcc66});
        
        // èšå…‰ç¯2ï¼ˆå†·è“è‰²ï¼Œå½¢æˆå¯¹æ¯”ï¼‰
        const spotLight2 = new THREE.SpotLight(0x6688ff, 600); 
        spotLight2.position.set(-30, 20, -30); 
        scene.add(spotLight2);
        dynamicLights.push({light: spotLight2, baseIntensity: 600, color: 0x6688ff});
        
        // æ–¹å‘å…‰ï¼ˆå¢å¼ºæ•´ä½“äº®åº¦ï¼‰
        const directionalLight = new THREE.DirectionalLight(0xffeebb, 0.8); 
        directionalLight.position.set(0, 0, 50); 
        scene.add(directionalLight);
        
        // æ·»åŠ é¢å¤–çš„è£…é¥°æ€§ç‚¹å…‰æºï¼ˆé—ªçƒæ•ˆæœï¼‰
        for(let i = 0; i < 3; i++) {
            const decorativeLight = new THREE.PointLight(
                0xffd700, 
                1.5, 
                15
            );
            const angle = (i / 3) * Math.PI * 2;
            decorativeLight.position.set(
                Math.cos(angle) * 25,
                10 + i * 5,
                Math.sin(angle) * 25
            );
            scene.add(decorativeLight);
            dynamicLights.push({
                light: decorativeLight, 
                baseIntensity: 1.5, 
                color: 0xffd700,
                phase: i * 2
            });
        }
    }
    
    /**
     * æ›´æ–°åŠ¨æ€å…‰ç…§æ•ˆæœ
     */
    function updateDynamicLights(time) {
        dynamicLights.forEach((lightData, index) => {
            const {light, baseIntensity, color, phase = 0} = lightData;
            // åˆ›å»ºå‘¼å¸ç¯æ•ˆæœ
            const intensity = baseIntensity * (1 + Math.sin(time * 2 + phase) * 0.3);
            light.intensity = intensity;
            
            // é¢œè‰²æ¸å˜æ•ˆæœï¼ˆä»…å¯¹ä¸­å¿ƒå…‰æºï¼‰
            if(index === 0) {
                const hue = (time * 0.1) % 1;
                const r = Math.sin(hue * Math.PI * 2) * 0.5 + 0.5;
                const g = Math.sin((hue + 0.33) * Math.PI * 2) * 0.5 + 0.5;
                const b = Math.sin((hue + 0.66) * Math.PI * 2) * 0.5 + 0.5;
                light.color.setRGB(r * 0.8 + 0.2, g * 0.6 + 0.4, b * 0.3);
            }
        });
    }
    /**
     * è®¾ç½®åå¤„ç†æ•ˆæœï¼ˆå¢å¼ºç‰ˆï¼šæ›´å¼ºçš„å…‰æ™•æ•ˆæœï¼‰
     * å¦‚æœåå¤„ç†åº“ä¸å¯ç”¨ï¼Œå°†è·³è¿‡åå¤„ç†æ•ˆæœï¼Œä½¿ç”¨æ™®é€šæ¸²æŸ“
     */
    function setupPostProcessing() { 
        try {
            // æ£€æŸ¥åå¤„ç†åº“æ˜¯å¦å¯ç”¨
            if (typeof EffectComposer === 'undefined' || 
                typeof RenderPass === 'undefined' || 
                typeof UnrealBloomPass === 'undefined') {
                console.log('åå¤„ç†åº“ä¸å¯ç”¨ï¼Œå°†ä½¿ç”¨æ™®é€šæ¸²æŸ“ï¼ˆä¸å½±å“ä¸»åŠŸèƒ½ï¼‰');
                composer = null; // æ ‡è®°ä¸ºä¸å¯ç”¨
                return;
            }
            
            const renderPass = new RenderPass(scene, camera); 
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5,  // åˆ†è¾¨ç‡
                0.4,  // å¼ºåº¦
                0.85  // åŠå¾„
            ); 
            // å¢å¼ºå…‰æ™•å‚æ•°
            bloomPass.threshold = 0.6;      // é™ä½é˜ˆå€¼ï¼Œè®©æ›´å¤šåŒºåŸŸå‘å…‰
            bloomPass.strength = 0.6;       // å¢å¼ºå…‰æ™•å¼ºåº¦
            bloomPass.radius = 0.5;         // å¢å¤§å…‰æ™•åŠå¾„
            
            composer = new EffectComposer(renderer); 
            composer.addPass(renderPass); 
            composer.addPass(bloomPass);
            console.log('åå¤„ç†æ•ˆæœå·²å¯ç”¨');
        } catch (error) {
            console.warn('åå¤„ç†è®¾ç½®å¤±è´¥:', error.message);
            composer = null; // æ ‡è®°ä¸ºä¸å¯ç”¨ï¼Œä½¿ç”¨æ™®é€šæ¸²æŸ“
        }
    }
    function createTextures() { const c=document.createElement('canvas'); c.width=128; c.height=128; const x=c.getContext('2d'); x.fillStyle='#ffffff'; x.fillRect(0,0,128,128); x.fillStyle='#880000'; x.beginPath(); for(let i=-128;i<256;i+=32){x.moveTo(i,0);x.lineTo(i+32,128);x.lineTo(i+16,128);x.lineTo(i-16,0);} x.fill(); caneTexture=new THREE.CanvasTexture(c); caneTexture.wrapS=caneTexture.wrapT=THREE.RepeatWrapping; caneTexture.repeat.set(3,3); }

    window.updateSnowSettings = () => { 
        CONFIG.snow.sizeBase = parseFloat(document.getElementById('slider-snow-size').value); 
        CONFIG.snow.count = parseInt(document.getElementById('slider-snow-count').value); 
        createSnow(); 
    };
    window.updateSnowSpeed = (v) => { 
        CONFIG.snow.speed = parseFloat(v); 
    };
    
    /**
     * åˆ›å»ºé›ªèŠ±å®ä¾‹åŒ–ç½‘æ ¼
     * ä½¿ç”¨ InstancedMesh ä¼˜åŒ–æ€§èƒ½ï¼Œæ‰€æœ‰é›ªèŠ±å…±äº«åŒä¸€ä¸ªå‡ ä½•ä½“å’Œæè´¨
     */
    function createSnow() {
        // æ¸…ç†æ—§çš„é›ªèŠ±
        if(snowInstancedMesh){
            scene.remove(snowInstancedMesh); 
            snowInstancedMesh.geometry.dispose(); 
            snowInstancedMesh.material.dispose(); 
            snowInstancedMesh = null; 
            snowData = [];
        }
        if(CONFIG.snow.count <= 0) return;
        
        // åˆ›å»ºé›ªèŠ±å‡ ä½•ä½“å’Œæè´¨ï¼ˆåŠé€æ˜ç»ç’ƒæ•ˆæœï¼‰
        const snowGeometry = new THREE.IcosahedronGeometry(CONFIG.snow.sizeBase, 0);
        const snowMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0,
            roughness: 0.15,
            transmission: 0.9,
            thickness: 0.5,
            envMapIntensity: 1.5,
            clearcoat: 1,
            clearcoatRoughness: 0.1,
            ior: 1.33
        });
        
        // åˆ›å»ºå®ä¾‹åŒ–ç½‘æ ¼
        snowInstancedMesh = new THREE.InstancedMesh(snowGeometry, snowMaterial, CONFIG.snow.count); 
        snowInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        
        // åˆå§‹åŒ–æ¯ä¸ªé›ªèŠ±çš„ä½ç½®ã€æ—‹è½¬å’ŒåŠ¨ç”»æ•°æ®
        for(let i = 0; i < CONFIG.snow.count; i++){
            // éšæœºåˆå§‹ä½ç½®
            snowDummy.position.set(
                (Math.random() - 0.5) * CONFIG.snow.range, 
                Math.random() * CONFIG.snow.range, 
                (Math.random() - 0.5) * CONFIG.snow.range
            );
            // éšæœºåˆå§‹æ—‹è½¬
            snowDummy.rotation.set(
                Math.random() * Math.PI, 
                Math.random() * Math.PI, 
                Math.random() * Math.PI
            );
            // éšæœºå¤§å°å˜åŒ–
            const scale = 0.5 + Math.random() * CONFIG.snow.sizeVar; 
            snowDummy.scale.set(scale, scale, scale); 
            snowDummy.updateMatrix();
            snowInstancedMesh.setMatrixAt(i, snowDummy.matrix);
            
            // å­˜å‚¨æ¯ä¸ªé›ªèŠ±çš„åŠ¨ç”»å‚æ•°
            snowData.push({
                vy: Math.random() * 0.5 + 0.8,  // å‚ç›´ä¸‹è½é€Ÿåº¦
                rx: (Math.random() - 0.5) * 2,  // Xè½´æ—‹è½¬é€Ÿåº¦
                ry: (Math.random() - 0.5) * 2,  // Yè½´æ—‹è½¬é€Ÿåº¦
                rz: (Math.random() - 0.5) * 2   // Zè½´æ—‹è½¬é€Ÿåº¦
            });
        } 
        scene.add(snowInstancedMesh);
    }

    /**
     * ç²’å­ç±»ï¼šç®¡ç†åœºæ™¯ä¸­çš„è£…é¥°ç²’å­ï¼ˆè£…é¥°å“ã€æ˜Ÿå°˜ã€ç…§ç‰‡ç­‰ï¼‰
     */
    class Particle {
        constructor(mesh, type, isDust = false){
            this.mesh = mesh;
            this.type = type;
            this.isDust = isDust;
            this.posTree = new THREE.Vector3();      // èšåˆæ¨¡å¼ï¼ˆåœ£è¯æ ‘ï¼‰ä½ç½®
            this.posScatter = new THREE.Vector3();   // æ•£å¼€æ¨¡å¼ï¼ˆæ˜Ÿäº‘ï¼‰ä½ç½®
            this.baseScale = mesh.scale.x;
            this.photoId = null;
            
            // æ ¹æ®ç±»å‹è®¾ç½®æ—‹è½¬é€Ÿåº¦ï¼ˆç…§ç‰‡æ—‹è½¬è¾ƒæ…¢ï¼‰
            const spinSpeedMultiplier = (type === 'PHOTO') ? 0.3 : 2.0;
            this.spinSpeed = new THREE.Vector3(
                (Math.random() - 0.5) * spinSpeedMultiplier,
                (Math.random() - 0.5) * spinSpeedMultiplier,
                (Math.random() - 0.5) * spinSpeedMultiplier
            );
            this.calcPos();
        }
        
        /**
         * è®¡ç®—ç²’å­çš„èšåˆå’Œæ•£å¼€ä½ç½®
         */
        calcPos(){
            const treeHeight = CONFIG.particles.treeHeight;
            // ä½¿ç”¨å¹‚å‡½æ•°ä½¿ç²’å­åˆ†å¸ƒæ›´é›†ä¸­åœ¨æ ‘çš„ä¸Šéƒ¨
            let t = Math.pow(Math.random(), 0.8);
            const y = (t * treeHeight) - (treeHeight / 2);
            // åŠå¾„éšé«˜åº¦å‡å°
            let radiusMultiplier = Math.max(0.5, CONFIG.particles.treeRadius * (1.0 - t));
            const angle = t * 50 * Math.PI + Math.random() * Math.PI;
            const radius = radiusMultiplier * (0.8 + Math.random() * 0.4);
            this.posTree.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
            
            // æ•£å¼€æ¨¡å¼ï¼šçƒé¢å‡åŒ€åˆ†å¸ƒ
            let scatterRadius = this.isDust ? (12 + Math.random() * 20) : (8 + Math.random() * 12);
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            this.posScatter.set(
                scatterRadius * Math.sin(phi) * Math.cos(theta),
                scatterRadius * Math.sin(phi) * Math.sin(theta),
                scatterRadius * Math.cos(phi)
            );
        }
        
        /**
         * æ›´æ–°ç²’å­ä½ç½®ã€æ—‹è½¬å’Œç¼©æ”¾
         * @param {number} dt - æ—¶é—´å¢é‡
         * @param {string} mode - å½“å‰æ¨¡å¼ï¼š'TREE' | 'SCATTER' | 'FOCUS'
         * @param {THREE.Object3D} focusTarget - ç„¦ç‚¹ç›®æ ‡ï¼ˆFOCUSæ¨¡å¼ä¸‹ï¼‰
         */
        update(dt, mode, focusTarget){
            // ç¡®å®šç›®æ ‡ä½ç½®
            let targetPos = this.posTree;
            if(mode === 'SCATTER'){
                targetPos = this.posScatter;
            } else if(mode === 'FOCUS'){
                if(this.mesh === focusTarget){
                    // ç„¦ç‚¹ç›®æ ‡ï¼šç§»åŠ¨åˆ°ç›¸æœºå‰æ–¹ç‰¹å®šä½ç½®
                    let offset = new THREE.Vector3(0, 1, 38);
                    if(STATE.focusType === 1) offset.set(-4, 2, 35);
                    else if(STATE.focusType === 2) offset.set(3, 0, 32);
                    else if(STATE.focusType === 3) offset.set(0, -2.5, 30);
                    const inverseMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                    targetPos = offset.applyMatrix4(inverseMatrix);
                } else {
                    targetPos = this.posScatter;
                }
            }
            
            // ä½ç½®æ’å€¼ï¼ˆç„¦ç‚¹ç›®æ ‡ç§»åŠ¨æ›´å¿«ï¼‰
            const lerpSpeed = (mode === 'FOCUS' && this.mesh === focusTarget) ? 8.0 : 4.0;
            this.mesh.position.lerp(targetPos, lerpSpeed * dt);
            
            // æ—‹è½¬æ›´æ–°
            if(mode === 'SCATTER'){
                // æ•£å¼€æ¨¡å¼ï¼šæŒç»­æ—‹è½¬
                this.mesh.rotation.x += this.spinSpeed.x * dt;
                this.mesh.rotation.y += this.spinSpeed.y * dt;
                this.mesh.rotation.z += this.spinSpeed.z * dt;
            } else if(mode === 'TREE'){
                // èšåˆæ¨¡å¼ï¼šå¹³æ»‘å›å½’åˆ°å‚ç›´ï¼ŒYè½´æŒç»­æ—‹è½¬
                this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
                this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
                this.mesh.rotation.y += 0.5 * dt;
            }
            
            // ç„¦ç‚¹æ¨¡å¼ï¼šé¢å‘ç›¸æœº
            if(mode === 'FOCUS' && this.mesh === focusTarget){
                this.mesh.lookAt(camera.position);
                // æ ¹æ®ç„¦ç‚¹ç±»å‹è°ƒæ•´è§’åº¦
                if(STATE.focusType === 1) this.mesh.rotateZ(0.38);
                else if(STATE.focusType === 2) this.mesh.rotateZ(-0.15);
                else if(STATE.focusType === 3) this.mesh.rotateX(-0.4);
            }
            
            // ç¼©æ”¾æ›´æ–°
            let targetScale = this.baseScale;
            if(this.isDust){
                // æ˜Ÿå°˜ï¼šé—ªçƒæ•ˆæœï¼Œèšåˆæ¨¡å¼ä¸‹éšè—
                targetScale = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
                if(mode === 'TREE') targetScale = 0;
                
                // åŠ¨æ€è°ƒæ•´æ˜Ÿå°˜å‘å…‰å¼ºåº¦
                if(this.mesh.material && this.mesh.material.emissiveIntensity !== undefined) {
                    const baseEmissive = 0.5;
                    const pulse = Math.sin(clock.elapsedTime * 3 + this.mesh.id) * 0.3;
                    this.mesh.material.emissiveIntensity = baseEmissive + pulse;
                }
            } else if(mode === 'SCATTER' && this.type === 'PHOTO'){
                // æ•£å¼€æ¨¡å¼ä¸‹ç…§ç‰‡æ”¾å¤§
                targetScale = this.baseScale * 2.5;
            } else if(mode === 'FOCUS'){
                if(this.mesh === focusTarget){
                    // ç„¦ç‚¹ç›®æ ‡ï¼šæ ¹æ®ç±»å‹è®¾ç½®ä¸åŒå¤§å°
                    if(STATE.focusType === 2) targetScale = 3.5;
                    else if(STATE.focusType === 3) targetScale = 4.8;
                    else targetScale = 3.0;
                } else {
                    // éç„¦ç‚¹ç›®æ ‡ï¼šç¼©å°
                    targetScale = this.baseScale * 0.8;
                }
            }
            this.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 6 * dt);
            
            // åŠ¨æ€è°ƒæ•´ç²’å­å‘å…‰æ•ˆæœï¼ˆæ ¹æ®æ¨¡å¼ï¼‰
            if(this.mesh.material && this.mesh.material.emissiveIntensity !== undefined && !this.isDust) {
                let targetEmissive = this.mesh.material.emissiveIntensity;
                if(mode === 'SCATTER') {
                    // æ•£å¼€æ¨¡å¼ï¼šå¢å¼ºå‘å…‰
                    targetEmissive = (this.mesh.material.emissiveIntensity || 0.3) * 1.5;
                } else if(mode === 'FOCUS' && this.mesh === focusTarget) {
                    // ç„¦ç‚¹æ¨¡å¼ï¼šå¼ºçƒˆå‘å…‰
                    targetEmissive = 1.0;
                }
                this.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(
                    this.mesh.material.emissiveIntensity || 0.3,
                    targetEmissive,
                    5 * dt
                );
            }
        }
    }

    /**
     * åˆ›å»ºè£…é¥°ç²’å­ï¼ˆå¢å¼ºç‰ˆï¼šæ›´ä¸°å¯Œçš„æè´¨å’Œå‘å…‰æ•ˆæœï¼‰
     */
    function createParticles() {
        const sg = new THREE.SphereGeometry(0.5, 32, 32); 
        const bg = new THREE.BoxGeometry(0.55, 0.55, 0.55); 
        const c = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, -0.5, 0),
            new THREE.Vector3(0, 0.3, 0),
            new THREE.Vector3(0.1, 0.5, 0),
            new THREE.Vector3(0.3, 0.4, 0)
        ]); 
        const cg = new THREE.TubeGeometry(c, 16, 0.08, 8, false);
        
        // å¢å¼ºçš„æè´¨ï¼šæ›´å¼ºçš„å‘å…‰å’Œåå°„
        const goldMaterial = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.champagneGold,
            metalness: 1,
            roughness: 0.1,
            envMapIntensity: 2.5,
            emissive: 0x664400,
            emissiveIntensity: 0.5  // å¢å¼ºå‘å…‰
        });
        
        const greenMaterial = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.deepGreen,
            metalness: 0.3,
            roughness: 0.7,
            envMapIntensity: 1.5,
            emissive: 0x004400,
            emissiveIntensity: 0.3
        });
        
        const redMaterial = new THREE.MeshPhysicalMaterial({
            color: CONFIG.colors.accentRed,
            metalness: 0.4,
            roughness: 0.15,
            clearcoat: 1,
            clearcoatRoughness: 0.1,
            emissive: 0x550000,
            emissiveIntensity: 0.4
        });
        
        const caneMaterial = new THREE.MeshStandardMaterial({
            map: caneTexture,
            roughness: 0.3,
            metalness: 0.5,
            envMapIntensity: 1.8
        });
        
        // åˆ›å»ºç²’å­
        for(let i = 0; i < CONFIG.particles.count; i++){
            const r = Math.random();
            let mesh, type;
            
            if(r < 0.4){
                mesh = new THREE.Mesh(bg, greenMaterial);
                type = 'BOX';
            } else if(r < 0.7){
                mesh = new THREE.Mesh(bg, goldMaterial);
                type = 'GOLD_BOX';
            } else if(r < 0.92){
                mesh = new THREE.Mesh(sg, goldMaterial);
                type = 'GOLD_SPHERE';
            } else if(r < 0.97){
                mesh = new THREE.Mesh(sg, redMaterial);
                type = 'RED';
            } else {
                mesh = new THREE.Mesh(cg, caneMaterial);
                type = 'CANE';
            }
            
            const scale = 0.4 + Math.random() * 0.5;
            mesh.scale.set(scale, scale, scale);
            mesh.rotation.set(
                Math.random() * 6, 
                Math.random() * 6, 
                Math.random() * 6
            );
            mainGroup.add(mesh);
            particleSystem.push(new Particle(mesh, type, false));
        }
        
        // é¡¶éƒ¨æ˜Ÿæ˜Ÿï¼ˆå¢å¼ºå‘å…‰æ•ˆæœï¼‰
        const starMaterial = new THREE.MeshStandardMaterial({
            color: 0xffdd88,
            emissive: 0xffaa00,
            emissiveIntensity: 1.5,  // å¢å¼ºå‘å…‰
            metalness: 1,
            roughness: 0,
            envMapIntensity: 3
        });
        const star = new THREE.Mesh(
            new THREE.OctahedronGeometry(1.2, 0), 
            starMaterial
        );
        star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
        mainGroup.add(star);
        mainGroup.add(photoMeshGroup);
    }
    /**
     * åˆ›å»ºæ˜Ÿå°˜ç²’å­ï¼ˆå¢å¼ºç‰ˆï¼šæ›´äº®çš„å‘å…‰æ•ˆæœï¼‰
     */
    function createDust(){
        const geometry = new THREE.TetrahedronGeometry(0.08, 0);
        // å¢å¼ºçš„æ˜Ÿå°˜æè´¨ï¼šæ›´äº®ã€æ›´é—ªçƒ
        const material = new THREE.MeshBasicMaterial({
            color: 0xffeebb,
            transparent: true,
            opacity: 0.9,
            emissive: 0xffeebb,
            emissiveIntensity: 0.5
        });
        
        for(let i = 0; i < CONFIG.particles.dustCount; i++){
            const mesh = new THREE.Mesh(geometry, material.clone());
            mesh.scale.setScalar(0.5 + Math.random());
            // æ·»åŠ éšæœºäº®åº¦å˜åŒ–
            mesh.material.opacity = 0.7 + Math.random() * 0.3;
            mainGroup.add(mesh);
            particleSystem.push(new Particle(mesh, 'DUST', true));
        }
    }
    function createDefaultPhotos(){const c=document.createElement('canvas');c.width=512;c.height=512;const x=c.getContext('2d');x.fillStyle='#050505';x.fillRect(0,0,512,512);x.strokeStyle='#eebb66';x.lineWidth=15;x.strokeRect(20,20,472,472);x.font='500 60px Times New Roman';x.fillStyle='#eebb66';x.textAlign='center';x.fillText("JOYEUX",256,230);x.fillText("NOEL",256,300);createPhotoTexture(c.toDataURL(),'default');}
    function createPhotoTexture(b,id){
        const i=new Image();
        i.onload=()=>{
            try {
                const t=new THREE.Texture(i);
                t.colorSpace=THREE.SRGBColorSpace;
                t.needsUpdate=true;
                addPhotoToScene(t,id,i);
            } catch(error) {
                console.error('åˆ›å»ºçº¹ç†å¤±è´¥:', error);
                showToast('ç…§ç‰‡åŠ è½½å¤±è´¥', 'error');
            }
        };
        i.onerror=()=>{
            console.error('å›¾ç‰‡åŠ è½½å¤±è´¥');
            showToast('å›¾ç‰‡æ ¼å¼ä¸æ”¯æŒæˆ–å·²æŸå', 'error');
        };
        i.src=b;
    }
    /**
     * å°†ç…§ç‰‡æ·»åŠ åˆ°åœºæ™¯ä¸­
     * @param {THREE.Texture} texture - ç…§ç‰‡çº¹ç†
     * @param {string} id - ç…§ç‰‡ID
     * @param {Image} imgObj - å›¾ç‰‡å¯¹è±¡
     */
    function addPhotoToScene(texture, id, imgObj){
        // å®‰å…¨æ£€æŸ¥ï¼šé˜²æ­¢é™¤é›¶é”™è¯¯
        if(!imgObj.width || !imgObj.height) {
            console.warn('å›¾ç‰‡å°ºå¯¸æ— æ•ˆ:', imgObj.width, imgObj.height);
            showToast('å›¾ç‰‡å°ºå¯¸æ— æ•ˆ', 'error');
            return;
        }
        
        const aspect = imgObj.width / imgObj.height;
        let width = 1.2;
        let height = 1.2;
        
        // æ ¹æ®å®½é«˜æ¯”è°ƒæ•´å°ºå¯¸
        if(aspect > 1) {
            height = width / aspect;
        } else {
            width = height * aspect;
        }
        
        // åˆ›å»ºç…§ç‰‡æ¡†æ¶
        const frameGeometry = new THREE.BoxGeometry(width + 0.2, height + 0.2, 0.05);
        const frameMaterial = new THREE.MeshStandardMaterial({
            color: 0xc5a059,
            metalness: 0.6,
            roughness: 0.5,
            envMapIntensity: 0.5
        });
        const frame = new THREE.Mesh(frameGeometry, frameMaterial);
        
        // åˆ›å»ºç…§ç‰‡å¹³é¢
        const photoGeometry = new THREE.PlaneGeometry(width, height);
        const photoMaterial = new THREE.MeshBasicMaterial({map: texture});
        const photo = new THREE.Mesh(photoGeometry, photoMaterial);
        photo.position.z = 0.04;
        
        // ç»„åˆæ¡†æ¶å’Œç…§ç‰‡
        const group = new THREE.Group();
        group.add(frame);
        group.add(photo);
        const scale = 0.8;
        group.scale.set(scale, scale, scale);
        
        photoMeshGroup.add(group);
        
        // åˆ›å»ºç²’å­å¯¹è±¡
        const particle = new Particle(group, 'PHOTO', false);
        particle.photoId = id;
        particle.texture = texture;
        particleSystem.push(particle);
    }
    /**
     * åº”ç”¨ç²’å­è®¾ç½®ï¼šé‡ç½®åœºæ™¯ç²’å­
     */
    window.applyParticleSettings = () => {
        try {
            // ä¿ç•™ç…§ç‰‡ç²’å­
            const photoParticles = particleSystem.filter(p => p.type === 'PHOTO');
            const toRemove = [];
            
            // æ”¶é›†éœ€è¦ç§»é™¤çš„ç‰©ä½“ï¼ˆä¿ç•™ç…§ç‰‡ç»„ï¼‰
            mainGroup.children.forEach(child => {
                if(child !== photoMeshGroup) {
                    toRemove.push(child);
                }
            });
            
            // ç§»é™¤æ—§ç²’å­
            toRemove.forEach(child => mainGroup.remove(child));
            
            // æ›´æ–°ç²’å­ç³»ç»Ÿ
            particleSystem = [...photoParticles];
            
            // è·å–æ–°çš„é…ç½®å€¼ï¼ˆå®‰å…¨æ£€æŸ¥ï¼‰
            const treeSlider = document.getElementById('slider-tree');
            const dustSlider = document.getElementById('slider-dust');
            
            if(treeSlider) CONFIG.particles.count = parseInt(treeSlider.value) || 1500;
            if(dustSlider) CONFIG.particles.dustCount = parseInt(dustSlider.value) || 2500;
            
            // é‡æ–°åˆ›å»ºç²’å­
            createParticles();
            createDust();
            createSnow();
            
            showToast('åœºæ™¯å·²é‡ç½®', 'success');
        } catch(error) {
            console.error('é‡ç½®åœºæ™¯å¤±è´¥:', error);
            showToast('é‡ç½®åœºæ™¯å¤±è´¥', 'error');
        }
    };

    /**
     * åˆå§‹åŒ–MediaPipeæ‰‹åŠ¿è¯†åˆ«
     * éœ€è¦ç½‘ç»œè¿æ¥åŠ è½½æ¨¡å‹ï¼Œå¤±è´¥ä¸å½±å“ä¸»ç¨‹åºè¿è¡Œ
     */
    async function initMediaPipe(){
        try {
            videoElement = document.getElementById('webcam-video');
            
            // è¯·æ±‚æ‘„åƒå¤´æƒé™
            if(navigator.mediaDevices?.getUserMedia){
                try{
                    const stream = await navigator.mediaDevices.getUserMedia({video: true});
                    videoElement.srcObject = stream;
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        renderWebcamPreview();
                    };
                } catch(e){
                    console.warn('æ‘„åƒå¤´è®¿é—®å¤±è´¥ï¼ˆå¯èƒ½éœ€è¦ç”¨æˆ·æˆæƒï¼‰:', e);
                    // æ‘„åƒå¤´å¤±è´¥ä¸å½±å“ç¨‹åºè¿è¡Œ
                }
            }
            
            // åˆå§‹åŒ–MediaPipeï¼ˆéœ€è¦ç½‘ç»œè¿æ¥ï¼‰
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                predictWebcam();
            } catch(e){
                console.warn('MediaPipeåˆå§‹åŒ–å¤±è´¥ï¼ˆéœ€è¦ç½‘ç»œè¿æ¥ï¼‰:', e);
                throw e; // é‡æ–°æŠ›å‡ºä»¥ä¾¿ä¸Šå±‚å¤„ç†
            }
        } catch(e) {
            console.warn('æ‰‹åŠ¿è¯†åˆ«åŠŸèƒ½ä¸å¯ç”¨:', e);
            // æ›´æ–°æç¤º
            const hint = document.getElementById('gesture-hint');
            if(hint) hint.innerText = "æ‰‹åŠ¿è¯†åˆ«ä¸å¯ç”¨ï¼ˆéœ€è¦ç½‘ç»œè¿æ¥ï¼‰ï¼Œå¯ä½¿ç”¨é”®ç›˜æ§åˆ¶";
            throw e; // é‡æ–°æŠ›å‡ºä»¥ä¾¿ä¸Šå±‚å¤„ç†
        }
    }
    function renderWebcamPreview(){const c=document.getElementById('webcam-canvas'),x=c.getContext('2d',{willReadFrequently:true});function d(){if(videoElement.readyState>=2)x.drawImage(videoElement,0,0,c.width,c.height);requestAnimationFrame(d)}d()}
    let lvt=-1;
    let lastPredictTime=0;
    const PREDICT_INTERVAL=33; // çº¦30fpsï¼ŒèŠ‚æµä¼˜åŒ–
    async function predictWebcam(){
        const now=performance.now();
        if(now-lastPredictTime<PREDICT_INTERVAL){
            requestAnimationFrame(predictWebcam);
            return;
        }
        lastPredictTime=now;
        if(videoElement&&videoElement.currentTime!==lvt&&handLandmarker){
            lvt=videoElement.currentTime;
            const r=handLandmarker.detectForVideo(videoElement,performance.now());
            processGestures(r);
            document.getElementById('cam-status').classList.toggle('active',r.landmarks.length>0);
        }
        requestAnimationFrame(predictWebcam);
    }
    /**
     * å¤„ç†æ‰‹åŠ¿è¯†åˆ«ç»“æœ
     * @param {Object} result - MediaPipe æ‰‹åŠ¿è¯†åˆ«ç»“æœ
     */
    function processGestures(result){
        if(result.landmarks && result.landmarks.length > 0){
            STATE.hand.detected = true;
            const landmarks = result.landmarks[0];
            
            // è·å–æ‰‹éƒ¨å…³é”®ç‚¹ä½ç½®ï¼ˆä¸­æŒ‡æ ¹éƒ¨ï¼Œç”¨äºæ§åˆ¶æ—‹è½¬ï¼‰
            STATE.hand.x = (landmarks[9].x - 0.5) * 2;
            STATE.hand.y = (landmarks[9].y - 0.5) * 2;
            
            // è·å–å…³é”®ç‚¹
            const thumb = landmarks[4];   // æ‹‡æŒ‡å°–
            const index = landmarks[8];    // é£ŸæŒ‡å°–
            const wrist = landmarks[0];    // æ‰‹è…•
            const middle = landmarks[12];  // ä¸­æŒ‡å°–
            
            // è®¡ç®—æ‰‹åŠ¿è·ç¦»
            const pinchDistance = Math.hypot(thumb.x - index.x, thumb.y - index.y);  // æåˆè·ç¦»
            const openDistance = Math.hypot(middle.x - wrist.x, middle.y - wrist.y);  // å¼ å¼€è·ç¦»
            
            // ç„¦ç‚¹æ¨¡å¼ä¸‹ï¼šæ¾å¼€æ‰‹åŠ¿é€€å‡ºç„¦ç‚¹
            if(STATE.mode === 'FOCUS'){
                if(pinchDistance > 0.1){
                    setMode('SCATTER');
                }
                return;
            }
            
            // æ‰‹åŠ¿è¯†åˆ«
            if(pinchDistance < 0.05 && STATE.mode !== 'FOCUS'){
                // æåˆæ‰‹åŠ¿ï¼šæŠ“å–ç…§ç‰‡
                triggerPhotoGrab();
            } else if(openDistance > 0.4){
                // å¼ å¼€æ‰‹åŠ¿ï¼šæ•£å¼€æ¨¡å¼
                setMode('SCATTER');
            } else if(openDistance < 0.2){
                // æ¡æ‹³æ‰‹åŠ¿ï¼šèšåˆæ¨¡å¼
                setMode('TREE');
            }
        } else {
            STATE.hand.detected = false;
        }
    }
    /**
     * æ‰“å¼€ç…§ç‰‡ç®¡ç†ç•Œé¢
     */
    window.openDeleteManager = async () => {
        try {
            const manager = document.getElementById('delete-manager');
            const grid = document.getElementById('photo-grid');
            
            if(!manager || !grid) {
                showToast('ç®¡ç†ç•Œé¢å…ƒç´ æœªæ‰¾åˆ°');
                return;
            }
            
            manager.classList.remove('hidden');
            grid.innerHTML = '';
            
            const photos = await loadPhotosFromDB();
            if(!photos || photos.length === 0) {
                grid.innerHTML = '<div style="color:#888; text-align:center; padding:20px;">æš‚æ— ç…§ç‰‡</div>';
            } else {
                photos.forEach(photo => {
                    const item = document.createElement('div');
                    item.className = 'photo-item';
                    
                    const img = document.createElement('img');
                    img.className = 'photo-thumb';
                    img.src = photo.data;
                    img.onerror = () => {
                        item.style.background = '#333';
                        item.innerHTML = '<div style="color:#888; text-align:center; padding-top:30px;">åŠ è½½å¤±è´¥</div>';
                    };
                    
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'delete-x';
                    deleteBtn.innerText = 'X';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        confirmDelete(photo.id, item);
                    };
                    
                    item.appendChild(img);
                    item.appendChild(deleteBtn);
                    grid.appendChild(item);
                });
            }
        } catch(error) {
            console.error('æ‰“å¼€ç®¡ç†ç•Œé¢å¤±è´¥:', error);
            showToast('æ‰“å¼€ç®¡ç†ç•Œé¢å¤±è´¥');
        }
    };
    
    /**
     * ç¡®è®¤åˆ é™¤ç…§ç‰‡
     */
    window.confirmDelete = (id, element) => {
        try {
            deletePhotoFromDB(id);
            if(element) element.remove();
            
            const particle = particleSystem.find(p => p.photoId === id);
            if(particle) {
                photoMeshGroup.remove(particle.mesh);
                // é‡Šæ”¾çº¹ç†èµ„æº
                if(particle.texture) {
                    particle.texture.dispose();
                }
                const index = particleSystem.indexOf(particle);
                if(index > -1) {
                    particleSystem.splice(index, 1);
                }
            }
            showToast('ç…§ç‰‡å·²åˆ é™¤', 'success');
        } catch(error) {
            console.error('åˆ é™¤ç…§ç‰‡å¤±è´¥:', error);
            showToast('åˆ é™¤å¤±è´¥', 'error');
        }
    };
    
    /**
     * æ¸…ç©ºæ‰€æœ‰ç…§ç‰‡
     */
    window.clearAllPhotos = () => {
        if(confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç…§ç‰‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼")) {
            try {
                clearPhotosDB();
                
                // ç§»é™¤åœºæ™¯ä¸­çš„ç…§ç‰‡å¹¶é‡Šæ”¾èµ„æº
                particleSystem.filter(p => p.type === 'PHOTO').forEach(particle => {
                    photoMeshGroup.remove(particle.mesh);
                    if(particle.texture) {
                        particle.texture.dispose();
                    }
                });
                
                particleSystem = particleSystem.filter(p => p.type !== 'PHOTO');
                window.openDeleteManager();
                showToast('æ‰€æœ‰ç…§ç‰‡å·²æ¸…ç©º', 'success');
            } catch(error) {
                console.error('æ¸…ç©ºç…§ç‰‡å¤±è´¥:', error);
                showToast('æ¸…ç©ºå¤±è´¥', 'error');
            }
        }
    };
    
    /**
     * å…³é—­ç…§ç‰‡ç®¡ç†ç•Œé¢
     */
    window.closeDeleteManager = () => {
        const manager = document.getElementById('delete-manager');
        if(manager) manager.classList.add('hidden');
    };

    function animate() {
        requestAnimationFrame(animate); 
        const dt = clock.getDelta(); 
        const et = clock.getElapsedTime();
        
        // é›ªèŠ±æ›´æ–°ä¼˜åŒ–ï¼šåªåœ¨ TREE æ¨¡å¼ä¸‹æ›´æ–°ï¼Œå‡å°‘ä¸å¿…è¦çš„è®¡ç®—
        if(snowInstancedMesh && STATE.mode === 'TREE'){
            snowInstancedMesh.visible = true;
            const snowSpeed = CONFIG.snow.speed * dt;
            const resetY = 40;
            const minY = -25;
            
            for(let i = 0; i < CONFIG.snow.count; i++){
                // è·å–å½“å‰çŸ©é˜µ
                snowInstancedMesh.getMatrixAt(i, snowDummy.matrix);
                snowDummy.matrix.decompose(snowDummy.position, snowDummy.quaternion, snowDummy.scale);
                
                const snowInfo = snowData[i];
                
                // æ›´æ–°ä½ç½®ï¼šä¸‹è½ + æ°´å¹³æ¼‚ç§»
                snowDummy.position.y -= snowInfo.vy * snowSpeed;
                snowDummy.position.x += Math.sin(et * 0.5 + i) * 2.5 * dt;
                snowDummy.position.z += Math.cos(et * 0.3 + i) * 1.5 * dt;
                
                // æ›´æ–°æ—‹è½¬
                snowDummy.rotation.x += snowInfo.rx * dt;
                snowDummy.rotation.y += snowInfo.ry * dt;
                snowDummy.rotation.z += snowInfo.rz * dt;
                
                // é‡ç½®è¶…å‡ºèŒƒå›´çš„é›ªèŠ±
                if(snowDummy.position.y < minY){
                    snowDummy.position.y = resetY;
                    snowDummy.position.x = (Math.random() - 0.5) * CONFIG.snow.range;
                    snowDummy.position.z = (Math.random() - 0.5) * CONFIG.snow.range;
                }
                
                // æ›´æ–°çŸ©é˜µ
                snowDummy.updateMatrix();
                snowInstancedMesh.setMatrixAt(i, snowDummy.matrix);
            } 
            snowInstancedMesh.instanceMatrix.needsUpdate = true;
        } else if(snowInstancedMesh) {
            snowInstancedMesh.visible = false;
        }

        // æ—‹è½¬é€»è¾‘æ›´æ–°
        if(manualRotateState.x !== 0 || manualRotateState.y !== 0){
            // æ‰‹åŠ¨æ—‹è½¬ï¼ˆé”®ç›˜/æŒ‰é’®æ§åˆ¶ï¼‰
            const speed = CONFIG.interaction.rotationSpeed * 2.0;
            STATE.rotation.x += manualRotateState.x * speed * dt;
            STATE.rotation.y += manualRotateState.y * speed * dt;
        } else if(STATE.mode === 'SCATTER' && STATE.hand.detected){
            // æ‰‹åŠ¿æ§åˆ¶æ—‹è½¬
            const threshold = 0.3;
            const speed = CONFIG.interaction.rotationSpeed;
            if(STATE.hand.x > threshold) {
                STATE.rotation.y -= speed * dt * (STATE.hand.x - threshold);
            } else if(STATE.hand.x < -threshold) {
                STATE.rotation.y -= speed * dt * (STATE.hand.x + threshold);
            }
            if(STATE.hand.y < -threshold) {
                STATE.rotation.x += speed * dt * (-STATE.hand.y - threshold);
            } else if(STATE.hand.y > threshold) {
                STATE.rotation.x -= speed * dt * (STATE.hand.y - threshold);
            }
        } else {
            // è‡ªåŠ¨æ—‹è½¬
            if(STATE.mode === 'TREE'){
                STATE.rotation.y += 0.3 * dt;
                STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt; // å¹³æ»‘å›å½’åˆ°æ°´å¹³
            } else {
                STATE.rotation.y += 0.1 * dt;
            }
        }
        
        // åº”ç”¨æ—‹è½¬åˆ°ä¸»ç»„
        mainGroup.rotation.y = STATE.rotation.y;
        mainGroup.rotation.x = STATE.rotation.x;
        
        // æ›´æ–°åŠ¨æ€å…‰ç…§æ•ˆæœ
        if(dynamicLights && dynamicLights.length > 0) {
            updateDynamicLights(et);
        }
        
        // æ›´æ–°æ‰€æœ‰ç²’å­
        particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
        
        // æ¸²æŸ“åœºæ™¯ï¼ˆå¦‚æœåå¤„ç†å¯ç”¨åˆ™ä½¿ç”¨ï¼Œå¦åˆ™ä½¿ç”¨æ™®é€šæ¸²æŸ“ï¼‰
        if (composer) {
            composer.render();
        } else {
            renderer.render(scene, camera);
        }
    }
    init();
</script></body></html>